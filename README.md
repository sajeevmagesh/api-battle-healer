# api-battle-healer

## FastAPI Mock Server

Install dependencies:

```bash
python3 -m venv .venv
source .venv/bin/activate
pip install -r requirements.txt
```

Run the server:

```bash
uvicorn backend.main:app --reload --host 0.0.0.0 --port 8000
```

### Endpoints

1. `POST /generate-api-key`
   - Body: `{ "userId": "demo-user" }`
   - Returns a token with quotas, retry budget, and TTL.

2. `POST /refresh-token`
   - Body: `{ "token": "<old>" }` (optional) to rotate credentials without waiting for expiry.

3. `GET|POST /simulate-budget`
   - Inspect or mutate per-token quota/ budget counters to force 402/429 behavior.

4. `GET|POST /queue-failed`
   - `POST` accepts structured request metadata (correlation ID, endpoint, provider, region, sanitized headers/body, error context) and enqueues it for async replay. A background worker replays queued requests with exponential backoff, marks entries as completed/dead, and emits `QUEUE_OVERFLOW` / `QUEUE_REPLAY_*` warnings. Persistence & external notifications are still TODO for now.

5. `POST /mock-response`
   - Return graceful-degradation payloads or feed your own fallback body.

6. `GET|POST /log`
   - Collect structured healing logs; `GET /log` echoes recent entries.

7. `GET|POST /external-api`
   - Requires `Authorization: Bearer <token>`.
   - Supports dev-time triggers (comma-delimited) through:
     - Header `X-Simulate-Failure: region_down,retryable_500,schema_drift,...`
     - Query string `?simulate=mock` or `?simulate=repair`.
   - Built-in scenarios:
     - Retryable failures: `retryable_500`, `region_down`, `quota`
     - Credential healing: tokens expire quickly; use `/refresh-token` or `/generate-api-key`
     - Request repair: include `simulate=repair` to force a 422 with schema hints
     - Schema drift: `schema_drift` randomly renames/omits fields
     - Graceful degradation: `mock` returns cached/stale payloads
     - Budget/quota exhaustion: adjust via `/simulate-budget` to trigger 402/429

8. `POST /simulate-budget`
   - Body: `{ "token": "...", "call_budget_delta": -10 }` etc.

### Queueing & Async Recovery

- `POST /queue-failed` accepts the failed request metadata described above. Entries are stored in-memory for now (look for the inline TODOs if you want to swap in SQLite/Redis/SQS for durability).
- A FastAPI startup task replays items every few seconds using exponential backoff. Successes are removed from the queue; repeated failures eventually become `dead` entries.
- Overflow + dead-letter thresholds emit structured `QUEUE_OVERFLOW`, `QUEUE_RETRY_SCHEDULED`, and `QUEUE_REPLAY_DEAD` logs that always carry the correlation ID, provider, region, and endpoint. Hook these into Slack/webhooks where the TODO comments sit today.
- Set `DISABLE_QUEUE_WORKER=1` in your `.env` if you need to turn the worker off locally (for tests or demos).

### Request Repair & Schema Drift

- The `/test-healing` playground now includes a “Use Gemini planner for repairs” toggle. When enabled, requests flow through `runHealingAgent`, which:
  - Captures the failing request + error details and hands them to Gemini for action selection.
  - Supports `rewrite_request` actions that rebuild the payload (with safety guards: max 2 repairs per request + per-endpoint throttling).
  - Invokes `adapt_schema`/`infer_schema` actions to record field mappings/defaults for schema drift, then normalizes the eventual success payload via `applySchemaAdaptation`.
- Sample failure to try:
  ```bash
  curl -i "${NEXT_PUBLIC_BACKEND_URL}/external-api?simulate=region_down,retryable_500,schema_drift,repair" \
    -H 'Authorization: Bearer bad-token' \
    -H 'Content-Type: application/json' \
    -d '{"txn_id":"broken","amt_value":15}'
  ```
  Run the same combo in `/test-healing` with the planner toggled on to watch Gemini rewrite the body, switch regions, map fields (e.g., `transactionId -> txn_id`), and deliver a normalized response.
- Degradation levels:
  - `none` – healthy response, cached for future stale fallbacks.
  - `stale-cache` – last known good value served from the in-memory cache (default TTL 5 minutes). Toggle via the `degradation.enableStaleCache` flag when calling `runHealingAgent`.
  - `mocked` – synthetic payload generated by `POST /mock-response` (LLM-backed placeholder). Enable via `degradation.enableMock`. The backend endpoint accepts schema hints/examples and returns `{ mock, degradation, reason, source }`.
  - `partial` – reserved for future partial responses.
- The agent attempts degraded responses in order: stale cache → mock → hard error. Disable either tier per endpoint through the `degradation` config.
- The Result panel + agent log now surface degradation badges so you can see exactly when a fallback was used.

### Quota & Cost Awareness

- Credentials now declare a `tier` (`primary`, `backup`, or `free-tier`), per-day call & token caps, and optional `estimatedCostPer1kTokens`.
- The pool tracks rolling call rates/tokens and emits `CREDENTIAL_QUOTA_SIGNAL` logs whenever a key is about to breach quota. When a primary key runs hot, the selector automatically rotates to the next tier (with a log like `credential_near_quota`).
- Helper endpoints:
  - `GET /queue-status` – counts queued/running jobs plus recent dead-letter activity.
  - `GET /logs?correlation_id=...` – pulls structured healing log events (the CLI uses this under the hood).

### Integrations (Python Decorator & CLI)

- **Python decorator (experimental)**:
  ```python
  from healing_sdk import heal_api_call

  @heal_api_call(endpoint="openai.chat", retry_attempts=1)
  def call_openai(prompt: str):
      ...
  ```
  On failure it retries once and queues the payload via `/queue-failed` so the backend can replay it. Configure the backend URL with `HEALER_BACKEND_URL`.

- **CLI helper** (`python/healing_cli.py`):
  ```
  python python/healing_cli.py test-request --simulate region_down,retryable_500
  python python/healing_cli.py queue-status
  python python/healing_cli.py logs --correlation-id corr-abc123
  ```
  The CLI hits the Next.js `api/heal-runner` route for `test-request`, so run `npm run dev` alongside the FastAPI backend.

### Example cURL Commands

```bash
# Create a token for demo-user
curl -i http://localhost:8000/generate-api-key \
  -H 'Content-Type: application/json' \
  -d '{"userId":"demo-user"}'

# Use the token to hit the protected API (force schema drift + retryable errors)
curl -i 'http://localhost:8000/external-api?simulate=schema_drift,retryable_500' \
  -H 'Authorization: Bearer token-1234...' \
  -H 'Content-Type: application/json' \
  -d '{"transactionId":"abc-123","amount":99.5}'

# Force quota exhaustion
curl -i http://localhost:8000/simulate-budget \
  -H 'Content-Type: application/json' \
  -d '{"token":"token-1234","quota_delta":-20}'

# Send a structured log from the agent
curl -i http://localhost:8000/log \
  -H 'Content-Type: application/json' \
  -d '{"event":"retry_attempt","metadata":{"attempt":1,"region":"us-east-1"}}'

# Request a graceful degradation payload
curl -s http://localhost:8000/mock-response \
  -H 'Content-Type: application/json' \
  -d '{"reason":"smoke-test","payload":{"message":"cached value"}}'
```

## Next.js Demo UI

Install Node dependencies (already defined in `package.json`):

```bash
npm install
```

Copy the example env file and adjust values as needed:

```bash
cp .env.local.example .env.local
```

Run both servers in separate terminals:

```bash
# Terminal 1: FastAPI backend
uvicorn backend.main:app --reload --host 0.0.0.0 --port 8000

# Terminal 2: Next.js frontend
npm run dev
```

Open http://localhost:3000 to generate keys, launch `/test-healing`, or try `/openai-test`.

## OpenAI SmartFetch Test

The Next.js app also includes `/openai-test`, which exercises `smartFetch` through a server-side proxy to OpenAI.

1. Copy `.env.local.example` to `.env.local` and set a valid key plus backend origin:
   ```
   OPENAI_API_KEY=sk-your-key
   NEXT_PUBLIC_BACKEND_URL=http://localhost:8000
   ```
2. Restart `npm run dev` so the environment variable loads.
3. Visit http://localhost:3000/openai-test, enter a prompt, and submit. The page calls `/api/openai-proxy`, which relays to OpenAI using your key while letting `smartFetch` handle retries/logging.

### Failure Trigger Cheatsheet

| Trigger Value | Effect |
| ------------- | ------ |
| `region_down` | Returns HTTP 503 with retry budget metadata (region failover) |
| `retryable_500` | Returns HTTP 500 and decrements retry budget |
| `quota` | Immediate 429 to test quota awareness |
| `schema_drift` | Response schema renamed/trimmed |
| `mock` | Returns mocked/stale payload |
| `repair` | Forces 422 with schema hints |
| `malformed` | Alias of `repair` for client testing |

## Gemini-Healing Agent

The TypeScript agent under `src/agent/` loops through decision cycles powered by Gemini 3:

1. Calls `smartFetch` once per cycle to gather fresh failure metadata.
2. Passes condensed state + history to Gemini via `getHealingDecision()`.
3. Executes the returned action through the healing toolkit (token refresh, region failover, schema adaptation, payload repair, queueing, degraded response, etc.).
4. Logs every intervention and continues until success, a graceful degradation, queued recovery, or abort.

Usage sketch:

```ts
import { runHealingAgent } from '@/src/agent';
import { fetchTestApiKey } from '@/src/apiKeys';

const result = await runHealingAgent({
  url: `${process.env.NEXT_PUBLIC_BACKEND_URL}/external-api?simulate=region_down,schema_drift`,
  options: {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ transactionId: 'demo-1', amount: 42 }),
  },
  regions: [
    process.env.NEXT_PUBLIC_BACKEND_URL!,
    'http://localhost:8000?region=eu',
  ],
  tokenProvider: () => fetchTestApiKey('agent-demo'),
  backendBaseUrl: process.env.NEXT_PUBLIC_BACKEND_URL!,
});
```

Set `GEMINI_API_KEY` (or `NEXT_PUBLIC_GEMINI_API_KEY`) to enable full Gemini planning; otherwise, heuristics handle the decision loop.
